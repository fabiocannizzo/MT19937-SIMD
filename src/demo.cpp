#include "VRandGen.h"

#include <array>
#include <memory>
#include <iostream>

// This is the initialization seed. Refer to the original MT19937 documentation.
const uint32_t seedlength = 4;
const uint32_t seedinit[seedlength] = { 0x123, 0x234, 0x345, 0x456 };

// show how to construct and use a geneartor with VecLen=128 and GenMode=QM_Block16
void demo128()
{
    std::cout << "example of how to use the generator with M=4 and SSE2 instructions\n";

    /*
        We use a jump ahead matrix of 2^1993X values, where X=log2(M)
        Use the following jump matrices, depending on the chosen number of bits :
            32 = > nullptr
            128 = > . / dat / F19935.bits
            256 = > . / dat / F19934.bits
            512 = > . / dat / F19933.bits

        With VecLen=128 bits we have M=128/32=4 state vectors.
        With M=4 we have X=5, i.e. we use the matrix for jump ahead of 2^19935 values
        When initializing with this matrix:
         - the 1st state is the same as the original MT19937
         - the 2nd state is shifted forward by 1*2^19935 values
         - the 3rd state is shifted forward by 2*2^19935 values
         - the 4th state is shifted forward by 3*2^19935 values
    */
    MT19937Matrix *jumpMatrix = new MT19937Matrix(std::string("./dat/F19935.bits"));

    /*
        Optionally, we could pass an additional jump matrix affecting all states
        This could be useful to create multiple independent streams for parallelization
        In this example we do not pass any matrix.
    */
    MT19937Matrix *commonJumpMatrix = nullptr;

    /*
        Create the generator

        VecLen must be one of{ 32, 128, 256, 512 }
        It determines the set of SIMD instructions usedand the dimension of the state vector
            32 = > no SIMD, state size = 640
            128 = > SSE2, state size = 640 * 4
            256 = > SSE2, state size = 640 * 8
            512 = > SSE2, state size = 640 * 16
        
        The second argument defines the generation mode. We will always query the generators
        in blocks of 16 random numbers
    */
    VMT19937<128, QM_Block16> mt(seedinit, seedlength, 0, commonJumpMatrix, jumpMatrix);

    // The jump matrix is no longer needed and can be released here.
    delete jumpMatrix;

    // Create storage vector aligned with cache lines, where we will store results
    AlignedVector<uint32_t, 64> buffer(16);

    // Query 10 times the generator in blocks of 16 numbers
    for (size_t i = 0; i < 10; ++i) {
        mt.genrand_uint32_blk16(buffer.data());
        for (size_t j = 0; j < 16; ++j)
            std::cout << buffer[j] << ", ";
    }
    std::cout << "\n";
}

// show how to construct multiple independent generators
void demoParallel()
{
    std::cout << "example of how to use multiple independent generators\n";

    // Get the relevant jump matrix. With 128 bits registers we pick F19935.bits
    const MT19937Matrix* jumpMatrix = new MT19937Matrix(std::string("./dat/F19935.bits"));

    // Get the chosen common jump matrix. The size of the junp matrix determines the period
    // before the stream generated by multiple genarators become overlapping.
    // We can think about this as the period of the parallel generator.
    // In this example we use the F00100.bits matrix.
    const MT19937Matrix* commonJumpMatrix = new MT19937Matrix(std::string("./dat/F00100.bits"));

    // an array of parallel independent generators, which are guaraneteed not to be overlapping
    // up to a period of 2^100
    std::array<std::unique_ptr<VMT19937<128, QM_Block16>>, 10> parallelGenerators;

    // Create 10 multiple parallel generators with VecLen=128 and QueryMode=Block16
    for (size_t i = 0; i < 10; ++i)
        parallelGenerators[i].reset(new VMT19937<128, QM_Block16>(seedinit, seedlength, i, commonJumpMatrix, jumpMatrix));

    // The jump matrices are no longer needed and can be released here.
    delete jumpMatrix;
    delete commonJumpMatrix;

    // Create storage vector aligned with cache lines, where we will store results
    AlignedVector<uint32_t, 64> buffer(16);

    // Query 10 times each of the generators in blocks of 16
    // We could also use mt.genrand_uint32(), which queries one number at a time, but it is slower.
    for (auto& g : parallelGenerators) {
        for (size_t i = 0; i < 10; ++i) {
            g->genrand_uint32_blk16(buffer.data());
            for (size_t j = 0; j < 16; ++j)
                std::cout << buffer[j] << ", ";
        }
        std::cout << "\n";
    }
}

int main()
{
    // show how to construct and use a geneartor with VecLen=128 and GenMode=QM_Block16
    demo128();
    std::cout << "\n\n\n";

    // show how to construct multiple independent generators
    demoParallel();

    return 0;
}
